/*
<metadata description="Create up to 25 Buttons, Switches, Faders or XYZ Pads.&#13;&#13;SWONIC.com | v1.2.3-dev"
          details="Turns your Lightpad into a flexible MIDI control surface. Set your desired amount of controls, their appearance and behaviour."
          target="Lightpad" tags="MIDI;Controller" canEmbedModes="false">

    <groups>
        <group name="control" displayName="Control *" count="25"/>
    </groups>

    <variables>
        <variable name="amount" displayName="Control Amount" type="int"
                  min="1" max="25" value="1"
                  tooltip="Number of controls to display, 1-16"/>
        <variable name="midiChannel" displayName="MIDI Channel" type="int"
                  min="1" max="16" value="1"
                  tooltip="MIDI channel that is used for all controls"/>

        <vector group="control" count="25"
                wantsGetFunctions="true" wantsSetFunctions="false">

            <variable name="ControlType" displayName="Type" type="option"
                      options="Button;Switch;Fader;XYZ Pad" value="Button"
                      tooltip="Button: Sends x CC, 127.&#13;Switch: Sends x CC, 127 or 0.&#13;Fader: Sends x CC or y CC, 0-127.&#13;XYZ-Pad: Sends x CC and y CC, 0-127"/>
            <variable name="ControlColour" displayName="Colour" type="colour"
                      value="random" tooltip="Colour of the control"/>
            <variable name="ControlPosX" displayName="x Position" type="int"
                      min="1" max="15" value="1"
                      tooltip="Horizontal position of the control, 1-15"/>
            <variable name="ControlPosY" displayName="y Position" type="int"
                      min="1" max="15" value="1"
                      tooltip="Vertical position of the control, 1-15"/>
            <variable name="ControlWidth" displayName="x Width" type="int"
                      min="1" max="15" value="1"
                      tooltip="Horizontal size of the control, 1-15"/>
            <variable name="ControlHeight" displayName="y Height" type="int"
                      min="1" max="15" value="1"
                      tooltip="Vertical size of the control, 1-15"/>
            <variable name="ControlCCA" displayName="x MIDI CC" type="int"
                      min="1" max="127" initStart="102"
                      tooltip="MIDI CC message for Strike (touch) and Glide (horizontal movement)"/>
            <variable name="ControlCCB" displayName="y MIDI CC" type="int"
                      min="1" max="127" initStart="102"
                      tooltip="MIDI CC message for Slide (vertical movement)"/>
            <variable name="ControlCCP" displayName="Pressure CC" type="int"
                      min="1" max="127" initStart="102"
                      tooltip="MIDI CC message for Press (pressure)"/>
            <variable name="SendPress" displayName="Send Pressure" type="bool"
                      value="false" tooltip="Activate to send z CC"/>
        </vector>

    </variables>
</metadata>
*/

//==============================================================================
//
//  DYNAMIC CONTROLS
//
//   ROLI Dashboard app for ROLI Lightpad BLOCK
//
//   developed by Anthony Alfimov & Andreas Swoboda (SWONIC)
//
//   contact: http://swonic.com | mail@swonic.com
//
//   copyright: Anthony Alfimov & Andreas Swoboda, 2018-2019
//
//   version: 1.2.3-dev
//
//==============================================================================

#heapsize: 275
//
//  Heap Layout
//  |-----------|-------------------------------------------------------------|
//  | bytes:    | data:
//  | 000 - 024 | 25 1-byte control CC1 values [0, 127]
//  | 025 - 049 | 25 1-byte control CC2 values [0, 127]
//  | 050 - 074 | 25 1-byte pressure values [0, 127]
//  |-----------|-------------------------------------------------------------|
//  | 075 - 099 | 25 1-byte control min X coordinates [0, 14]
//  | 100 - 124 | 25 1-byte control max X coordinates [0, 14]
//  | 125 - 149 | 25 1-byte control min Y coordinates [0, 14]
//  | 150 - 174 | 25 1-byte control max Y coordinates [0, 14]
//  |-----------|-------------------------------------------------------------|
//  | 175 - 274 | 25 4-byte bitfields for touches registered on a control
//  |-----------|-------------------------------------------------------------|
//

//==============================================================================
//  Global Constants
//==============================================================================

const int MAX_CONTROLS = 25;
const int STATUS_CC = 0xb0;                 // status byte template for CC messages

// Control types
const int C_BUTTON = 0;
const int C_SWITCH = 1;
const int C_FADER  = 2;
const int C_XYZPAD = 3;

//==============================================================================
//  Heap Setters and Getters
//==============================================================================
//------------------------------------------------------------------------------
//  Control Values
//------------------------------------------------------------------------------
void setControlValueA(int controlIndex, int value)  { setHeapByte(controlIndex, value); }
int  getControlValueA(int controlIndex)             { return getHeapByte(controlIndex); }

void setControlValueB(int controlIndex, int value)  { setHeapByte(controlIndex + 25, value); }
int  getControlValueB(int controlIndex)             { return getHeapByte(controlIndex + 25); }

void setPressureValue(int controlIndex, int value)  { setHeapByte(controlIndex + 50, value); }

int getHighlight(int controlIndex)
{
    return getHeapByte(controlIndex + 50) * 2 + 1;
}

//------------------------------------------------------------------------------
//  Coordinates
//------------------------------------------------------------------------------
void setControlMinX(int controlIndex, int minX)     { setHeapByte(controlIndex + 75, minX); }
int  getControlMinX(int controlIndex)               { return getHeapByte(controlIndex + 75); }

void setControlMaxX(int controlIndex, int maxX)     { setHeapByte(controlIndex + 100, maxX); }
int  getControlMaxX(int controlIndex)               { return getHeapByte(controlIndex + 100); }

void setControlMinY(int controlIndex, int minY)     { setHeapByte(controlIndex + 125, minY); }
int  getControlMinY(int controlIndex)               { return getHeapByte(controlIndex + 125); }

void setControlMaxY(int controlIndex, int maxY)     { setHeapByte(controlIndex + 150, maxY); }
int  getControlMaxY(int controlIndex)               { return getHeapByte(controlIndex + 150); }

int  getControlSizeX(int controlIndex)
{
    return getControlMaxX(controlIndex) - getControlMinX(controlIndex) + 1;
}

int  getControlSizeY(int controlIndex)
{
    return getControlMaxY(controlIndex) - getControlMinY(controlIndex) + 1;
}

//------------------------------------------------------------------------------
//  Touch Bit Fields
//------------------------------------------------------------------------------
void setControlTouchField(int controlIndex, int touchField) { setHeapInt(controlIndex * 4 + 175, touchField); }
int  getControlTouchField(int controlIndex)                 { return getHeapInt(controlIndex * 4 + 175); }

//==============================================================================
//  Conversion Functions and Helpers
//==============================================================================

// Convert touch positin on a control to CC value [0, 127]
//     position in (0, 2); pixelMin and pixelMax in [0, 14]
int convertPositionToCC(float position, int pixelMin, int pixelMax)
{
    // Coordinate conversion from (0.0, 2.0) to (0.0, 15.0)
    position = position * 0.5 * 15;

    // TODO: if stack size allows after UI update, save offset as a const
    // map [min + d, max + 1 - d] to [0, 127]; d = 0.6 - edge offset
    position = map(position, float(pixelMin) + 0.6, float(pixelMax) + 0.4,
                   0.0, 128.0);

    return clamp(0, 127, int(position));
}

// Convert CC value to a pixel value
//..

bool isFaderVertical(int controlIndex)
{
    // use integer division: 0 if horizontal, >=1 if vertical or square
    return getControlSizeY(controlIndex) / getControlSizeX(controlIndex);
}

//==============================================================================
//  Handle Touch
//==============================================================================

void doTouch(int touchIndex, float x, float y, float z)
{
    // NOTE: whole system breaks if a touch with touchIndex > 30 is registered.
    //       But how and why would this ever happen?

    // Coordinate conversion from (0.0, 2.0) to [0, 14]
    int intX = int(x * 0.5 * 15.0);
    int intY = int(y * 0.5 * 15.0);

    int touchedControl = -1;
    int touchFlag = 1 << touchIndex;        // bitflag for current touch

    for (int i = amount - 1; i >= 0; --i)                               // start counting ctrls from the top
    {
        if (   intX >= getControlMinX(i) && intX <= getControlMaxX(i)
            && intY >= getControlMinY(i) && intY <= getControlMaxY(i))
        {
            int touchField = getControlTouchField(i);                   // fetch bitfield with registered touches for ctrl
            int controlType = getControlType(i);
            bool isHighestTouch = !(touchField >> (touchIndex + 1));    // are there any touches with higher index registered to the control?

            if (controlType == C_BUTTON && !touchField)                 // is a button and no other touches present
                doButton(i, true);
            else if (controlType == C_SWITCH && !touchField)            // is a switch and no other touches present
                doSwitch(i);
            else if (controlType == C_FADER && isHighestTouch)          // is a fader and highest touch index
                doFader(i, x, y);
            else if (controlType == C_XYZPAD && isHighestTouch)         // is a pad and highest touch index
                doXYZPad(i, x, y);

            if (getSendPress(i) && isHighestTouch)                      // send pressure and highest touch
            {
                int pressure = clamp(0, 127, int(z * 127.0));
                sendCC(midiChannel, getControlCCP(i), pressure);
                setPressureValue(i, pressure);
            }

            touchField = touchField | touchFlag;                        // register current touch with ctrl
            setControlTouchField(i, touchField);                        // write updated bitfield for ctrl

            touchedControl = i;             // save index of touched ctrl
            break;                          // if overlap is not used, stop checking lower ctrls
        }
        else
        {
            doTouchEnd(i, touchFlag);       // unregister touch from ctrl
        }
    }

    for (int i = touchedControl - 1; i >= 0; --i)                       // go through remaining controls and unregister touch
    {
        doTouchEnd(i, touchFlag);
    }
}

void doTouchEnd(int controlIndex, int touchFlag)
{
    int touchField = getControlTouchField(controlIndex);                // fetch bitfield with registered touches for ctrl

    if (touchField & touchFlag)                                         // if touch was registered with current ctrl
    {
        touchField = touchField & ~touchFlag;                           // unregister touch from ctrl
        setControlTouchField(controlIndex, touchField);

        if (!touchField && getControlType(controlIndex) == C_BUTTON)    // if no touches left registered AND is a button
            doButton(controlIndex, false);
    }
}

void doButton(int controlIndex, bool isActive)
{
    int value = isActive ? 127 : 0;
    sendCC(midiChannel, getControlCCA(controlIndex), value);
    setControlValueA(controlIndex, value);
}

void doSwitch(int controlIndex)
{
    int value = (getControlValueA(controlIndex) == 0) ? 127 : 0;
    sendCC(midiChannel, getControlCCA(controlIndex), value);
    setControlValueA(controlIndex, value);
}

void doFader(int controlIndex, float x, float y)
{
    int value;

    if (isFaderVertical(controlIndex))
        value = 127 - convertPositionToCC(y, getControlMinY(controlIndex),
                                             getControlMaxY(controlIndex));
    else
        value = convertPositionToCC(x, getControlMinX(controlIndex),
                                       getControlMaxX(controlIndex));

    sendCC(midiChannel, getControlCCA(controlIndex), value);
    setControlValueA(controlIndex, value);
}

void doXYZPad(int controlIndex, float x, float y)
{
    int valueX = convertPositionToCC(x, getControlMinX(controlIndex),
                                        getControlMaxX(controlIndex));
    int valueY = 127 - convertPositionToCC(y, getControlMinY(controlIndex),
                                              getControlMaxY(controlIndex));

    sendCC(midiChannel, getControlCCA(controlIndex), valueX);
    sendCC(midiChannel, getControlCCB(controlIndex), valueY);
    setControlValueA(controlIndex, valueX);
    setControlValueB(controlIndex, valueY);
}

void touchStart(int index, float x, float y, float z, float vz)
{
    doTouch(index, x, y, z);
}

void touchMove(int index, float x, float y, float z, float vz)
{
    doTouch(index, x, y, z);
    //log(getTimeInCurrentFunctionCall());
}

void touchEnd (int touchIndex, float x, float y, float z, float vz)
{
    int touchFlag = 1 << touchIndex;        // bitflag for current touch

    for (int i = 0; i < amount; ++i)        // unregister touch from all ctrls
    {
        doTouchEnd(i, touchFlag);
    }
}

//==============================================================================
//  Handle Incoming MIDI
//==============================================================================

// OPTIMISATION: how long does MIDI handling take? does it slow down the app?
//               is it important to have it?

void handleMIDI(int byteStatus, int byteCC, int byteValue)
{
    byteStatus = byteStatus ^ STATUS_CC;    // flip CC template bits in status byte
                                            //   if status byte is a CC message,
                                            //   the result is its MIDI channel

    // OPTIMISATION: we can assume that one CC should be assigned to only one
    //               ctrl and break the loop once we get a match, plus make
    //               the check for CC B an `else if`.
    //               If multiple ctrls are assigned the same CC, only the
    //               first match will react to external MIDI.

    if (byteStatus == midiChannel)
        for (int i = 0; i < amount; ++i)
        {
            if (getControlCCA(i) == byteCC)
                setControlValueA(i, byteValue);
            if (getControlType(i) == C_XYZPAD   // check CC B only for XYZ pads
                     && getControlCCB(i) == byteCC)
                setControlValueB(i, byteValue);
        }
}

//==============================================================================
//  Initialisation
//==============================================================================

void initialise()
{
//  Update global MIDI channel value to [0, 15]
    midiChannel -= 1;

//  Initialise Control Values and Control/Touch table
    for (int i = 0; i < MAX_CONTROLS; ++i)
    {
        setControlValueA(i, 0);
        setControlValueB(i, 0);
        setPressureValue(i, 64);
        setControlTouchField(i, 0);
    }

//  Precalculate control coordinates
    for (int i = 0; i < amount; ++i)
    {
    //  Mix X [0, 14]
        int minX = clamp(0, 14, getControlPosX(i) - 1);
        setControlMinX(i, minX);

    //  Max X [0, 14]
        int maxX = clamp(0, 14, getControlPosX(i) + getControlWidth(i) - 2);
        setControlMaxX(i, maxX);

    //  Min Y [0, 14]
        int minY = clamp(0, 14, 16 - getControlPosY(i) - getControlHeight(i));
        setControlMinY(i, minY);

    //  Max Y [0, 14]
        int maxY = clamp(0, 14, 15 - getControlPosY(i));
        setControlMaxY(i, maxY);
    }

    // IDEA: should we initialise the unused controls to 0 just in case?
}

//==============================================================================
//  Graphics Functions
//==============================================================================

void drawButton(int colour, int controlIndex)
{
    int halfShade, fullShade;

    if (getControlTouchField(controlIndex))     // if control is active
    {
        // TODO: consider improving readability of colour constants (make actual constants?)
        fullShade = blendARGB(colour, 0xFFFFFF | (getHighlight(controlIndex) << 24));
        halfShade = blendARGB(colour, 0xFFFFFF | ((getHighlight(controlIndex) / 10) << 24));
    }
    else
    {
        fullShade = blendARGB(colour, 0xCC000000);
        halfShade = blendARGB(colour, 0x66000000);
    }

    blendGradientRect(colour, halfShade, fullShade, halfShade,
					  getControlMinX(controlIndex),  getControlMinY(controlIndex),
					  getControlSizeX(controlIndex), getControlSizeY(controlIndex));
}

// pixelMin and pixelMax can be swapped to invert the value
int convertCCToPixels(int valueCC, int pixelMin, int pixelMax)
{
    return int(map(float(valueCC), 0.0, 127.0, float(pixelMin), float(pixelMax)));
}

// int convertCCtoPixels(int value, int pixelMin, int pixelMax, float valMin, float valMax)
// {
//     value = int(map(float(value), valMin, valMax, float(pixelMin), float(pixelMax + 1)));
//     return clamp(pixelMin, pixelMax, value);
// }

//==============================================================================
//  Repaint
//==============================================================================

void repaint()
{
    clearDisplay();

    //     int controlType;
//     int activeColour, inactiveColour, hColour;       // FIXME: inactive colout is not always used!
//
//     bool isActive;


    for (int i = 0; i < amount; ++i)
    {
        int controlType = getControlType(i);
        int activeColour = getControlColour(i);
        // TODO: consider improving readability of colour constants (make actual constants?)
        int inactiveColour = blendARGB(activeColour, 0xEE000000);


        int minX = getControlMinX(i);
        int minY = getControlMinY(i);
        int sizeX = getControlSizeX(i);
        int sizeY = getControlSizeY(i);

        if (controlType == C_BUTTON)
        {
            if (getControlValueA(i) == 0)
                drawButton(activeColour, i);    //  Inactive Button
            else
                drawButton(inactiveColour, i);  //  Active Button
        }
        else if (controlType == C_SWITCH)
        {
            if (getControlValueA(i) == 0)
                drawButton(inactiveColour, i);  //  Inactive Button
            else
                drawButton(activeColour, i);    //  Active Button
        }
        else if (controlType == C_FADER)
        {
            int highlight = getControlTouchField(i) ? blendARGB(activeColour, 0xFFFFFF | (getHighlight(i) << 24)) : activeColour;

            int bgMinColour = blendARGB(activeColour, 0xFB000000);

            if (isFaderVertical(i))
            {
            //  Draw fader background
                blendGradientRect(inactiveColour, inactiveColour, bgMinColour, bgMinColour,
			        minX,  minY,
                    sizeX, sizeY);

            // Draw fader
                int pixelInvSize = convertCCToPixels(getControlValueA(i),
                    sizeY, 0);

                blendGradientRect(highlight, highlight, activeColour, activeColour,
                    minX,
                    minY + pixelInvSize,
                    sizeX,
                    sizeY - pixelInvSize);
            }
            else
            {
            //  Draw fader background
                blendGradientRect(bgMinColour, inactiveColour, inactiveColour, bgMinColour,
			        minX,  minY,
                    sizeX, sizeY);

            // Draw fader
                int pixelInvSize = convertCCToPixels(getControlValueA(i),
                    sizeX, 0);

                blendGradientRect(activeColour, highlight, highlight, activeColour,
                    minX,
                    minY,
                    sizeX - pixelInvSize,
                    sizeY);
            }
        }
        else if (controlType == C_XYZPAD)
        {
            //  Draw Pad
            fillRect(inactiveColour,
                     minX,  minY,
                     sizeX, sizeY);

            //  Draw Cross
            int pixelX = convertCCToPixels(getControlValueA(i),
                                           minX, getControlMaxX(i) + 1);
            pixelX = clamp(minX, getControlMaxX(i), pixelX);

            int pixelY = convertCCToPixels(getControlValueB(i),
                                           getControlMaxY(i) + 1, minY);
            pixelY = clamp(minY, getControlMaxY(i), pixelY);

            if (getControlTouchField(i))
                activeColour = blendARGB(activeColour, 0xFFFFFF | (getHighlight(i) << 24));

            // Vertical line
            fillRect(activeColour,
                     minX,  pixelY,
                     sizeX, 1);

            // Horizontal line
            fillRect(activeColour,
                     pixelX, minY,
                     1,      sizeY);
        }
    }

    log(getTimeInCurrentFunctionCall());
}

/*
<display backgroundColour="0xFF7E7E7E" textColour ="0xFFFFFFFF">
    <pixels>
        <pixel index="1" colour="0xFFD37201" />
        <pixel index="2" colour="0xFFD37201" />
        <pixel index="4" colour="0xFFD37201" />
        <pixel index="5" colour="0xFFD37201" />
        <pixel index="7" colour="0xFFD37201" />
        <pixel index="8" colour="0xFFD37201" />
        <pixel index="10" colour="0xFFD37201" />
        <pixel index="11" colour="0xFFD37201" />
        <pixel index="13" colour="0xFFD37201" />
        <pixel index="14" colour="0xFFD37201" />
        <pixel index="16" colour="0xFFD37201" />
        <pixel index="17" colour="0xFFD37201" />
        <pixel index="19" colour="0xFFD37201" />
        <pixel index="20" colour="0xFFD37201" />
        <pixel index="22" colour="0xFFD37201" />
        <pixel index="23" colour="0xFFD37201" />
        <pixel index="25" colour="0xFFD37201" />
        <pixel index="26" colour="0xFFD37201" />
        <pixel index="28" colour="0xFFD37201" />
        <pixel index="29" colour="0xFFD37201" />
        <pixel index="31" colour="0xFFD37201" />
        <pixel index="32" colour="0xFFD37201" />
        <pixel index="34" colour="0xFFD37201" />
        <pixel index="35" colour="0xFFD37201" />
        <pixel index="46" colour="0xFFD37201" />
        <pixel index="47" colour="0xFFD37201" />
        <pixel index="49" colour="0xFFD37201" />
        <pixel index="50" colour="0xFFD37201" />
        <pixel index="52" colour="0xFFD37201" />
        <pixel index="53" colour="0xFFD37201" />
        <pixel index="55" colour="0xFFD37201" />
        <pixel index="56" colour="0xFFD37201" />
        <pixel index="58" colour="0xFFD37201" />
        <pixel index="59" colour="0xFFD37201" />
        <pixel index="61" colour="0xFFD37201" />
        <pixel index="62" colour="0xFFD37201" />
        <pixel index="64" colour="0xFFD37201" />
        <pixel index="65" colour="0xFFD37201" />
        <pixel index="67" colour="0xFFD37201" />
        <pixel index="68" colour="0xFFD37201" />
        <pixel index="70" colour="0xFFD37201" />
        <pixel index="71" colour="0xFFD37201" />
        <pixel index="73" colour="0xFFD37201" />
        <pixel index="74" colour="0xFFD37201" />
        <pixel index="76" colour="0xFFD37201" />
        <pixel index="77" colour="0xFFD37201" />
        <pixel index="79" colour="0xFFD37201" />
        <pixel index="80" colour="0xFFD37201" />
        <pixel index="91" colour="0xFFD37201" />
        <pixel index="92" colour="0xFFD37201" />
        <pixel index="94" colour="0xFFD37201" />
        <pixel index="95" colour="0xFFD37201" />
        <pixel index="97" colour="0xFFD37201" />
        <pixel index="98" colour="0xFFD37201" />
        <pixel index="99" colour="0xFFD37201" />
        <pixel index="100" colour="0xFFD37201" />
        <pixel index="101" colour="0xFFD37201" />
        <pixel index="102" colour="0xFFD37201" />
        <pixel index="103" colour="0xFFD37201" />
        <pixel index="104" colour="0xFFD37201" />
        <pixel index="106" colour="0xFFD37201" />
        <pixel index="107" colour="0xFFD37201" />
        <pixel index="109" colour="0xFFD37201" />
        <pixel index="110" colour="0xFFD37201" />
        <pixel index="112" colour="0xFFD37201" />
        <pixel index="113" colour="0xFFD37201" />
        <pixel index="114" colour="0xFFD37201" />
        <pixel index="115" colour="0xFFD37201" />
        <pixel index="116" colour="0xFFD37201" />
        <pixel index="117" colour="0xFFD37201" />
        <pixel index="118" colour="0xFFD37201" />
        <pixel index="119" colour="0xFFD37201" />
        <pixel index="121" colour="0xFFD37201" />
        <pixel index="122" colour="0xFFD37201" />
        <pixel index="124" colour="0xFFD37201" />
        <pixel index="125" colour="0xFFD37201" />
        <pixel index="127" colour="0xFFD37201" />
        <pixel index="128" colour="0xFFD37201" />
        <pixel index="129" colour="0xFFD37201" />
        <pixel index="130" colour="0xFFD37201" />
        <pixel index="131" colour="0xFFD37201" />
        <pixel index="132" colour="0xFFD37201" />
        <pixel index="133" colour="0xFFD37201" />
        <pixel index="134" colour="0xFFD37201" />
        <pixel index="136" colour="0xFFD37201" />
        <pixel index="137" colour="0xFFD37201" />
        <pixel index="139" colour="0xFFD37201" />
        <pixel index="140" colour="0xFFD37201" />
        <pixel index="142" colour="0xFFD37201" />
        <pixel index="143" colour="0xFFD37201" />
        <pixel index="144" colour="0xFFD37201" />
        <pixel index="145" colour="0xFFD37201" />
        <pixel index="146" colour="0xFFD37201" />
        <pixel index="147" colour="0xFFD37201" />
        <pixel index="148" colour="0xFFD37201" />
        <pixel index="149" colour="0xFFD37201" />
        <pixel index="151" colour="0xFFD37201" />
        <pixel index="152" colour="0xFFD37201" />
        <pixel index="154" colour="0xFFD37201" />
        <pixel index="155" colour="0xFFD37201" />
        <pixel index="157" colour="0xFFD37201" />
        <pixel index="158" colour="0xFFD37201" />
        <pixel index="159" colour="0xFFD37201" />
        <pixel index="160" colour="0xFFD37201" />
        <pixel index="161" colour="0xFFD37201" />
        <pixel index="162" colour="0xFFD37201" />
        <pixel index="163" colour="0xFFD37201" />
        <pixel index="164" colour="0xFFD37201" />
        <pixel index="166" colour="0xFFD37201" />
        <pixel index="167" colour="0xFFD37201" />
        <pixel index="169" colour="0xFFD37201" />
        <pixel index="170" colour="0xFFD37201" />
        <pixel index="172" colour="0xFFD37201" />
        <pixel index="173" colour="0xFFD37201" />
        <pixel index="174" colour="0xFFD37201" />
        <pixel index="175" colour="0xFFD37201" />
        <pixel index="176" colour="0xFFD37201" />
        <pixel index="177" colour="0xFFD37201" />
        <pixel index="178" colour="0xFFD37201" />
        <pixel index="179" colour="0xFFD37201" />
        <pixel index="181" colour="0xFFD37201" />
        <pixel index="182" colour="0xFFD37201" />
        <pixel index="184" colour="0xFFD37201" />
        <pixel index="185" colour="0xFFD37201" />
        <pixel index="187" colour="0xFFD37201" />
        <pixel index="188" colour="0xFFD37201" />
        <pixel index="189" colour="0xFFD37201" />
        <pixel index="190" colour="0xFFD37201" />
        <pixel index="191" colour="0xFFD37201" />
        <pixel index="192" colour="0xFFD37201" />
        <pixel index="193" colour="0xFFD37201" />
        <pixel index="194" colour="0xFFD37201" />
        <pixel index="196" colour="0xFFD37201" />
        <pixel index="197" colour="0xFFD37201" />
        <pixel index="199" colour="0xFFD37201" />
        <pixel index="200" colour="0xFFD37201" />
        <pixel index="202" colour="0xFFD37201" />
        <pixel index="203" colour="0xFFD37201" />
        <pixel index="204" colour="0xFFD37201" />
        <pixel index="205" colour="0xFFD37201" />
        <pixel index="206" colour="0xFFD37201" />
        <pixel index="207" colour="0xFFD37201" />
        <pixel index="208" colour="0xFFD37201" />
        <pixel index="209" colour="0xFFD37201" />
    </pixels>
</display>
*/
