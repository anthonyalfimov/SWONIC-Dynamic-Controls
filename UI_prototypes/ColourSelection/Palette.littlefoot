/*
<metadata description="Basic colourmap script demonstrating the use of lib_ColourTools">

</metadata>
*/

int activeTouches;                              // holds bit flags for active touches
int colourMapAlpha;                             // alpha value to dim the colourmap
bool useSaturation;                             // colour map mode

//==============================================================================
//  HSV to RGB conversion
//==============================================================================
/**
    All-integer function.
    NB! Currently this function does not provide range safety for
        h, s, v parameters

    Combines a set of 8-bit AHSV values into a 32-bit colour and returns the result.

    alpha   - The alpha in range 0 - 255 inclusive (1 byte)
    h       - The hue in range 0 - 255 inclusive (1 byte)
    s       - The saturation in range 0 - 255 inclusive (1 byte)
    v       - The value (brightness) in range 0 - 255 inclusive (1 byte)
    returns - a 32-bit colour
*/
int makeARGBfromAHSV(int alpha, int h, int s, int v)
{
    // TODO: range safety for h, s, v parameters + test performance hit

    // If grayscale:
    if (s == 0)
        return makeARGB(alpha, v, v, v);

    int region     = h / 43;
    int remainder  = h - (region * 43);   // range 0 - 42

    int p, q, t;
    p = v * (255 - s) / 255;
    q = v * (255 - (s * remainder) / 43) / 255;
    t = v * (255 - (s * (43 - remainder)) / 43) / 255;

    if (region == 0)
        return makeARGB(alpha, v, t, p);
    else if (region == 1)
        return makeARGB(alpha, q, v, p);
    else if (region == 2)
        return makeARGB(alpha, p, v, t);
    else if (region == 3)
        return makeARGB(alpha, p, q, v);
    else if (region == 4)
        return makeARGB(alpha, t, p, v);
    else
        return makeARGB(alpha, v, p, q);
}

// Sets and unsets bit flags for touches 
void setTouch(int touchIndex, bool shouldBeActive)
{
    activeTouches = shouldBeActive ? (activeTouches | (1 << touchIndex))
                                   : (activeTouches & ~(1 << touchIndex));
}

// Simple colour map function
void fillHVColourMap()
{
    for (int x = 0; x < 15; x++)
        for (int y = 0; y < 15; y++)
            blendPixel(makeARGBfromAHSV(colourMapAlpha, 18 * x, 255, 255 - 18 * y), x, y);
}

void fillHSColourMap()
{
    for (int x = 0; x < 15; x++)
        for (int y = 0; y < 15; y++)
            blendPixel(makeARGBfromAHSV(colourMapAlpha, 18 * x, 255 - 18 * y, 255), x, y);
}

void initialise()
{
    activeTouches = 0;
    useSaturation = false;
    
    setLocalConfigActiveState (33, true, false);        // enable gamma correction parameter
}

void repaint()
{
    // If any touch is active, dim the colourmap
    colourMapAlpha = activeTouches ? 100 : 255;
    
    clearDisplay();
    
    if (useSaturation)
        fillHSColourMap();
    else
        fillHVColourMap();
    
    // Overlay heatmap
    drawPressureMap();
    fadePressureMap();
}

// For the sake of example we don't bother to be very precise with 
//     calculating colour from touch location to exactly match
//     the colour of the colourmap underneath

void touchStart (int index, float x, float y, float z, float vz)
{
    int colour = makeARGBfromAHSV(255, int(255.0 * x / 2.0), 255, 255);
    addPressurePoint (colour, x * 0.93, y * 0.93, z * 100.0);
    setTouch(index, true);
}

void touchMove (int index, float x, float y, float z, float vz)
{
    int colour = makeARGBfromAHSV(255, int(255.0 * x / 2.0), 255, 255);
    addPressurePoint (colour, x * 0.93, y * 0.93, z * 40.0);
}

void touchEnd (int index, float x, float y, float z, float vz)
{
    setTouch(index, false);
}


void handleButtonDown (int index)
{
    useSaturation = ! useSaturation;
}
